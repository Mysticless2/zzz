local play = game.Players.LocalPlayer
game.Workspace:WaitForChild(play.Name)
local char = play.Character
local hum = char:WaitForChild("Humanoid")
local mouse = play:GetMouse()
for a, b in pairs(game.Workspace.Thrown:GetChildren()) do
	if b.Name ~= "Amaterasu" then
		b:Destroy()
	end
end
local ts = game:GetService("TweenService")
local function thinring(cf, size, color)
	local tring = script.ThinRing:clone()
	tring.Color = color
	tring.CFrame = cf
	tring.Parent = game.Workspace.Thrown
	ts:Create(tring, TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
		Size = tring.Size * size,
		Transparency = 1
	}):Play()
	game.Debris:AddItem(tring, 0.5)
end
-----------LIGHTNING STRIKE----------------------------------------------------------------------------------------------------------------------------------------------------------
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")
local hb = game:GetService("RunService").Heartbeat
local work = workspace:FindFirstChild("Effects") or workspace
local Random = math.random
local Floor = math.floor
local Ceil = math.ceil
local NewInstance = Instance.new
local NewBrickColor = BrickColor.new
local Vec3 = Vector3.new
local Sub = string.sub
local Len = string.len
local CF = CFrame.new
local NumRange = NumberRange.new
local TRemove = table.remove
local TInfo = TweenInfo.new
local Rad = math.rad
local PI = math.pi
local Gravity = workspace.Gravity

--[[spawn(function()
	game.ReplicatedStorage.Watergunthing.OnClientEvent:Connect(function(part)
		while part and part.Parent and part.Parent == game.Workspace.Thrown and part.Anchored == true and part.hashot.Value == false do 
			local ring = script["Yoink Ring"]:Clone()
			ring.CFrame = part.CFrame
			ring.Parent = game.Workspace.Thrown
			local tweenInfo = TweenInfo.new(.8, Enum.EasingStyle.Quart)
			local part = ring
			ring.CFrame = ring.CFrame *CFrame.Angles(math.rad(90), 0, 0)
			local tween1 = TweenService:Create(part, tweenInfo, {Transparency = 1, Size = part.Size + Vector3.new(4, .4, 4)})tween1:Play()
			game.Debris:AddItem(ring, 1)
			wait()
		end
	end)
end)]]















local function R()
	return (Random()-0.5)
end

local lBase = NewInstance("Part")					--Lightning Segment Base
lBase.BrickColor = NewBrickColor("New Yeller")
lBase.Material = Enum.Material.Neon
lBase.Anchored = true
lBase.CanCollide = false
lBase.FormFactor = Enum.FormFactor.Custom
lBase.Size = Vector3.new(0.35,0.35,1)
lBase.Name = "LightningSegment"
local light = script:WaitForChild("PointLight"):Clone()
light.Parent = lBase

lBase2 = lBase:Clone()
lBase2.BrickColor = BrickColor.new("Electric blue")

local function GenerateLightning(startPos, endPos, length, timeAlive, timeFade, fasz, filler)
	spawn(function()
		length = length or 3
		timeAlive = timeAlive or 0.1
		timeFade = timeFade or 0.1
		local pos = startPos
		local dir = (endPos - startPos).unit
		local dist = (startPos - endPos).magnitude
		local prevDir = dir
		local l = {}

		local lcount = Ceil(dist/length)
		for i = 1, lcount do 
			if i == lcount then
				if fasz then
					l[i] = lBase2:Clone()
				else
					l[i] = lBase:Clone()
				end
				l[i].Size = Vector3.new(lBase.Size.X,lBase.Size.Y,(pos-endPos).magnitude)
				l[i].CFrame = CFrame.new((pos + endPos)/2, endPos)
			else
				if fasz then
					l[i] = lBase2:Clone()
				else
					l[i] = lBase:Clone()
				end
				l[i].Size = Vector3.new(lBase.Size.X, lBase.Size.Y, length)
				local offset = Vector3.new(R(), R(), R())
				local newPos = pos+(prevDir+dir+offset).unit*length
				l[i].CFrame = CFrame.new((pos+newPos)/2, newPos)

				if i > 1 then
					prevDir = l[i].CFrame.lookVector
				end
				pos = l[i].CFrame.p + l[i].CFrame.lookVector*(length/2)
				dir = (endPos-pos).unit
			end
		end
		for i = 1, #l do
			l[i].Parent = work
			Debris:AddItem(l[i], timeAlive+timeFade)
		end

		if timeFade > 0 then
			local ti = TInfo(timeFade,Enum.EasingStyle.Linear)
			local trans = {Transparency = 1}
			spawn(function()
				wait(timeAlive)
				for i = 1, #l do
					TweenService:Create(l[i], ti, trans):Play()
				end
			end)
		end
		return l
	end)
end
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
local function upanim(eroot)
	Spawn(function()
		for i = 1, 3 do
			local tring = script.ThinRing:clone()
			tring.CFrame = CFrame.new(eroot.Position) * CFrame.Angles(math.rad(-90), 0, 0) * CFrame.new(0, 0, 20)
			tring.Parent = game.Workspace.Thrown
			ts:Create(tring, TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
				Size = tring.Size * 20,
				Transparency = 1,
				CFrame = tring.CFrame * CFrame.new(0, 0, -30)
			}):Play()
			game.Debris:AddItem(tring, 0.5)
			wait(0.1)
		end
	end)
	local s = script.Up:Clone()
	s.Parent = eroot
	s:Play()
	game.Debris:AddItem(s, 2)
	Spawn(function()
		for i = 1, 22 do
			local part = script.Line:clone()
			part.CFrame = CFrame.new(eroot.Position) * CFrame.Angles(math.rad(-90), 0, 0) * CFrame.new(math.random(-5, 5), math.random(-5, 5), math.random(-10, 10))
			part.Parent = game.Workspace.Thrown
			ts:Create(part, TweenInfo.new(math.random(10, 100) / 100, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
				CFrame = part.CFrame * CFrame.new(0, 0, math.random(30, 60)),
				Transparency = 1
			}):Play()
			game.Debris:AddItem(part, 1)
		end
	end)
end
local function LookVectorKnockBack(parent,part,power,removaltime)
	spawn(function()
		local bv = Instance.new("BodyVelocity")----NEW METHOD HEH
		bv.Name = "BodyVel"
		bv.MaxForce =  Vector3.new(40000,40000,40000)
		bv.velocity =  part.CFrame.lookVector * power --+ Vector3.new(0,10,0)
		bv.Parent = parent
		game.Debris:AddItem(bv,removaltime)
	end)
end
local cam = game.Workspace.CurrentCamera
local function LookAt(part,length)
	spawn(function()
		for i = 1,length do wait()
			cam.CFrame = CFrame.new(cam.CFrame * CFrame.new(2,-2,0).p, part.Position)
		end
	end)
end
local function DirectionalKnockBack(part1,part2,power,removaltime,bool)
	spawn(function()
		local bv = Instance.new("BodyVelocity")----NEW METHOD HEH
		bv.Name = "BodyVel"
		bv.MaxForce =  Vector3.new(40000,40000,40000)
		if bool == false then
			bv.MaxForce =  Vector3.new(10000,0,10000)
		end
		local d = (part1.Position - part2.Position).unit
		bv.velocity =  (d * power) --+ Vector3.new(0,15,0) 
		bv.Parent = part1
		game.Debris:AddItem(bv,removaltime)
	end)
end
local function RemoveVelocity(Char)
	spawn(function()
		for i,v in pairs(Char.HumanoidRootPart:GetChildren()) do
			if v:FindFirstChild("BodyVelocity") then
				v:Destroy()
			end
		end
	end)
	spawn(function()
		for i,v in pairs(Char.Head:GetChildren()) do
			if v:FindFirstChild("BodyVelocity") then
				v:Destroy()
			end
		end	
	end)
	spawn(function()
		for i,v in pairs(Char.Torso:GetChildren()) do
			if v:FindFirstChild("BodyVelocity") then
				v:Destroy()
			end
		end	
	end)
end

local function FloatingRocks(Center)
	spawn(function()
		for i = 1, 10 do
			wait(0.02)
			local Rock = script.Debris2:Clone()
			Rock.Transparency = 0
			Rock.Material = "Neon"
			Rock.Anchored = false
			Rock.CanCollide = false
			Rock.BrickColor = BrickColor.new("Institutional white")
			local RandomX = math.random(-6 , 6)
			local RandomY = math.random(-3 , -2)
			local RandomZ = math.random(-6 , 6)
			local RandomCFrame = CFrame.new(RandomX , RandomY , RandomZ)
			Rock.CFrame = Center * RandomCFrame * CFrame.Angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360))
			Rock.Velocity = Rock.CFrame.lookVector * 10 + Vector3.new(0, 40, 0)
			Rock.Parent = workspace.Thrown
			local TweenStart = TweenInfo.new(0.8, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true)
			local TweenStartInformation = ts:Create(Rock, TweenStart, {
				Transparency = 1
			})
			TweenStartInformation:Play()
			Debris:AddItem(Rock , 1)
		end
	end)
end	

local function Debris(pos, copypart, size,HugeParticles)
	spawn(function()


		local part2 = script.Debris2:Clone()
		part2.CFrame = CFrame.new(pos)
		part2.Parent = workspace.Thrown
		local PartColor = copypart.Color
		local Red = PartColor.r * 255
		local Green = PartColor.g * 255
		local Blue = PartColor.b * 255
		--print("COLOR IS "..colorconvert)
		if HugeParticles then
			local emitthing = math.random(10,15)
			part2.BigParti:Emit(emitthing)
			game.Debris:AddItem(part2,10)
		else
			part2.Parti.Color = ColorSequence.new(Color3.fromRGB(Red,Green,Blue))
			local emitthing = math.random(10,15)+size/2
			part2.Parti:Emit(emitthing)
			game.Debris:AddItem(part2,10)
		end
		local PartAmount = math.random(7,15)
		if HugeParticles then
			PartAmount = math.random(2,3)	
		end
		for i = 1,PartAmount do


			local part = script.Debris:clone()
			part.Parent = game.Workspace.Thrown
			part.Size = part.Size * math.random(.5,1)
			part.CFrame = CFrame.new(pos) * CFrame.new(math.random(-5,5),0,math.random(-5,5))
			part.Velocity = Vector3.new(math.random(-75,75),math.random(45,75),math.random(-75,75))
			part.BrickColor = copypart.BrickColor
			part.Material = copypart.Material
			spawn(function()
				wait(.75)
				local ti = TweenInfo.new(3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true)
				local tween1 = ts:Create(part, ti, {
					Transparency = 1
				})
				tween1:Play()
				game.Debris:AddItem(part, 3)
			end)
		end
	end)
end		

local en = true

local function PresetEffect(Model,CF,Size,Speed,Color)
	spawn(function()
		if Model == nil then return end
		Model = Model:Clone()
		Model.Parent = game.Workspace.Thrown
		Model:SetPrimaryPartCFrame(CF)
		if Color == nil then
			Color = Color3.fromRGB(255,255,255)
		end
		for i,v in pairs(Model:GetChildren()) do
			spawn(function()
				if v.Name == "Color" then
					v.Color = Color
				end
				ts:Create(v, TweenInfo.new(Speed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false), {Transparency = 1,Size = v.Size * Size}):Play()	
			end)
		end
		game.Debris:AddItem(Model,Speed + 1)
	end)
end








local function waterdragontail(dragon,length)
	spawn(function()
		for i = 1,length do
			game:GetService("RunService").Heartbeat:wait()
			local trail = script.WaterDragonTrail:Clone()
			trail.CFrame = dragon.CFrame * CFrame.new(0,0,8.5) * CFrame.Angles(0,math.pi/2,0)
			trail.Anchored = true
			trail.CanCollide = false
			trail.Parent = game.Workspace.Thrown
			game.Debris:AddItem(trail,.55)
			if dragon.Anchored == true then break end
			if dragon == nil then break end
		end
	end)
end

local function winddragontail(dragon,length)
	spawn(function()
		for i = 1,length do
			game:GetService("RunService").Heartbeat:wait()
			local trail = game.ReplicatedStorage.WindDragonTrail:Clone()
			trail.CFrame = dragon.CFrame * CFrame.new(0,0,8.5) * CFrame.Angles(0,math.pi/2,0)
			trail.Anchored = true
			trail.CanCollide = false
			trail.Parent = game.Workspace.Thrown
			game.Debris:AddItem(trail,.55)
			if dragon.Anchored == true then break end
			if dragon == nil then break end
		end
	end)
end

local function bodyflicker(CFF, CFF2, Originalplayer)
	if Originalplayer and Originalplayer.Character then
		if play ~= Originalplayer then
			local pos1 = CFF
			local pos2 = CFF2

			local Root = script.Partugh:Clone()
			local SHUNPO = script.Shunpough:Clone()
			SHUNPO.CFrame = Root.CFrame
			SHUNPO.Parent = workspace
			SHUNPO.ParticleEmitter:Emit(5)
			Root.Parent = workspace
			game.Debris:AddItem(SHUNPO,2)
			game.Debris:AddItem(Root,2)
			Root.CFrame = CFF2
			Root.Size = Vector3.new(.01, .01, .01)
			SHUNPO.Size = Vector3.new(.01, .01, .01)
			Root:FindFirstChild("MoveT").Enabled = true
			wait()
			Root.CFrame = CFF
			local s = Instance.new("Sound")
			s.Parent = Root
			s.SoundId = "rbxassetid://79101985"
			s.PlaybackSpeed = math.random(50,52)/10
			s.Volume = 1
			s:Play()
			wait(.15)
			Root:FindFirstChild("MoveT").Enabled = false
			wait(1.25)
			if Root then
				Root:Destroy()
			end
		end
	end
end

local function SmokeFade(CF2,FadeTime,Size,Color,Transparency)
	local PART = script.RedSmoke:Clone()
	PART.CFrame = CF2
	PART.Anchored = true
	PART.Color = Color
	PART.Transparency = Transparency
	PART.Size = Vector3.new(Size,Size,Size)
	local CF = CF2 * CFrame.new(math.random(-Size,Size),math.random(0,Size/2),math.random(-Size,Size))
	local Pi1 = math.random(-math.pi,math.pi)
	local Pi2 = math.random(-math.pi,math.pi)
	local Pi3 = math.random(-math.pi,math.pi)
	CF = CF * CFrame.Angles(Pi1,Pi2,Pi3)
	local Mesh = Instance.new("BlockMesh")
	Mesh.Scale = Vector3.new(.1,.1,.1)
	Mesh.Parent = PART
	PART.Parent = workspace.Thrown
	local DB = false
	ts:Create(PART, TweenInfo.new(.25, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false),
		{CFrame = CF}):Play()
	ts:Create(Mesh, TweenInfo.new(.25, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false),
		{Scale = Vector3.new(1,1,1)}):Play()
	spawn(function()
		wait(.25)
		ts:Create(PART, TweenInfo.new(FadeTime, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false),
			{Transparency = 1,Size = PART.Size * 1.25}):Play()
		game.Debris:AddItem(PART,FadeTime)
	end)	
	PART.Anchored = true
end

local function combatknockback(root,eroot,velocity,timee,airvel)
	spawn(function()
		-----------------------------------------------------------------------Lock On Velocity---------------------
		if root:FindFirstChild("Lockon") then
			root:FindFirstChild("Lockon"):Destroy()
		end
		if eroot.Parent.Head:FindFirstChild("Lockon") then
			eroot.Parent.Head:FindFirstChild("Lockon"):Destroy()
		end
		local bv = Instance.new("BodyVelocity")----NEW METHOD HEH
		bv.Name = "Lockon"
		bv.MaxForce =  Vector3.new(10000,10000,10000)
		local bv2 = Instance.new("BodyVelocity")----NEW METHOD HEH
		bv2.Name = "Lockon"
		bv2.MaxForce = Vector3.new(10000,10000,10000)
		local d = (eroot.Position - root.Position).unit
		bv.velocity =  (d * 15) 
		bv2.velocity =  (d * velocity) 
		bv2.Parent = eroot.Parent.Head
		bv.Parent =root
		if airvel then
			timee = .6
			bv2.MaxForce = Vector3.new(1e8,math.huge,1e8)
			bv2.velocity =  (d * 25)  + Vector3.new(0,25,0)
			bv:Destroy() 
		end
		game.Debris:AddItem(bv, .2)
		game.Debris:AddItem(bv2, timee)

	end)
end
local function gust(eroot)
	spawn(function()
		local cfr = eroot.CFrame*CFrame.new(0,-8,0) * CFrame.Angles(0, 0, 0) 
		for i = 1, 10 do
			local tring = script.Gust:Clone()
			tring.CFrame =cfr
			tring.Parent = game.Workspace.Thrown
			ts:Create(tring, TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
				Size = tring.Size * 15,
				Transparency = 1,
				CFrame = tring.CFrame * CFrame.new(0, 22, -0)
			}):Play()

			game.Debris:AddItem(tring, 0.5)
			wait(0.1)
		end
	end)
end

local function hoppa(eroot)
	spawn(function()
		local cfr = eroot.CFrame*CFrame.new(0,-8,0) * CFrame.Angles(0, 0, 0) 
		for i = 1, 10 do
			local tring = script.Hoppa:Clone()
			tring.CFrame =cfr
			tring.Parent = game.Workspace.Thrown
			ts:Create(tring, TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
				Size = tring.Size * 15,
				Transparency = 1,
				CFrame = tring.CFrame * CFrame.new(0, 22, -0)
			}):Play()

			game.Debris:AddItem(tring, 0.5)
			wait(0.1)
		end
	end)
end

local function sphereshockwave(eroot,Sizee,Colorr,Amount)
	spawn(function()

		local cfr = eroot.CFrame*CFrame.new(0,-2,0) * CFrame.Angles(0, 0, 0) 

		for i = 1, Amount do
			local tring = script.Shock:Clone()
			tring.CFrame =cfr
			tring.Parent = game.Workspace.Thrown
			tring.Color = Colorr
			ts:Create(tring, TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
				Size = tring.Size * Sizee,
				Transparency = 1,
			}):Play()
			local Ball = script.Sphere:Clone()
			Ball.Parent = workspace.Thrown
			Ball.CFrame = eroot.CFrame
			Ball.Color = Colorr
			game.Debris:AddItem(Ball,.5)
			ts:Create(Ball, TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
				Size = Ball.Size * Sizee,
				Transparency = 1,
			}):Play()
			game.Debris:AddItem(tring, 0.5)

			wait()

			wait()
		end
	end)
end


local function sphereshockwave2(eroot,Sizee,Colorr,Amount)
	spawn(function()

		local cfr = eroot.CFrame*CFrame.new(0,-2,0) * CFrame.Angles(0, 0, 0) 

		for i = 1, Amount do

			local Ball = script.Sphere:Clone()
			Ball.Parent = workspace.Thrown
			Ball.CFrame = eroot.CFrame
			Ball.Color = Colorr
			game.Debris:AddItem(Ball,.5)
			ts:Create(Ball, TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
				Size = Ball.Size * Sizee,
				Transparency = 1,
			}):Play()
			wait()
		end
	end)
end


local function bleed(part,am,character)
	if character:FindFirstChild("Blood") then return end
	spawn(function()
		local Value = Instance.new("BoolValue",character)	
		Value.Name = "Blood"
		game.Debris:AddItem(Value,.25)
	end)
	if am > 5 then
		am = 5
	end
	for i=1,am do
		Spawn(function()
			local b = Instance.new("Part")
			b.Size = Vector3.new(0.2,0.4,0.2)
			b.CanCollide  = false
			b.Name = "Blood"
			b.BrickColor  =BrickColor.new("Crimson") 
			b.TopSurface = Enum.SurfaceType.Smooth
			b.BottomSurface = Enum.SurfaceType.Smooth
			local point = character["HumanoidRootPart"].Position + Vector3.new(math.random(-45,45)/10,0,math.random(-45,45)/10)
			local h,p,sf = ray(point,point - Vector3.new(0,2,0), 15, game.Workspace.LivingThings)

			if h and p and h.Anchored == true and h.CanCollide == true  then
				b.CFrame = character.Torso.CFrame
				local bf = Instance.new("BodyForce")
				bf.Force = Vector3.new(0,b:GetMass()*196,0)
				bf.Parent = b
				b.Velocity =  CFrame.new(part.Position,p).lookVector * 20
				b.Parent = workspace.Thrown
				local CFramee = CFrame.new(p)
				CFramee = CFramee * CFrame.Angles(0,0,0)
				ts:Create(b, TweenInfo.new(0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false), {CFrame = CFramee}):Play()
				b.Anchored = true
				p =  p - Vector3.new(0,1,0) 
				local cl = Instance.new("CylinderMesh")
				cl.Parent = b
				local r = math.random(20,60)/10
				cl.Offset = Vector3.new(0,0,0)
				wait(.1)
				r = r * math.random(1,2)
				ts:Create(cl, TweenInfo.new(0.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false), {Scale = Vector3.new(r, 0.2, r)}):Play()
				spawn(function()
					wait(.15)
					ts:Create(b, TweenInfo.new(35, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false), {Transparency = 1}):Play()
					ts:Create(cl, TweenInfo.new(35, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false), {Scale = Vector3.new(r*4, 0.2, r*4)}):Play()
				end)
				game.Debris:AddItem(b,35)
			else
				wait(2)
				b:Destroy() 
			end
		end)
	end
end




local function Clone(char,root,cf,length,animid)
	local CLONE1 = char:Clone()
	CLONE1.HumanoidRootPart.CFrame = cf
	CLONE1.HumanoidRootPart.Anchored = true
	CLONE1.Parent = game.Workspace
	CLONE1.Zanpakto.Blade.Blade.SwordTrail.Enabled = true
	CLONE1.HumanoidRootPart.SwingFist:Play()
	local Animation = Instance.new("Animation")
	Animation.AnimationId = animid
	local ANIMM = CLONE1.Humanoid:LoadAnimation(Animation)
	ANIMM:Play()
	game.Debris:AddItem(CLONE1,length)
end	



local function Flash(Charr,Color)
	spawn(function()
		local Descen = Charr:GetDescendants()
		for i,v in pairs(Descen) do

			if v:IsA("BasePart") and v.Transparency == 0 then

				local F = v:Clone()
				if F:FindFirstChildWhichIsA("Decal") then
					F:FindFirstChildWhichIsA("Decal"):Destroy()	
				end
				if F.Name == "Handle" then
					if F:FindFirstChild("Mesh") then
						F.Mesh.TextureId = ""
						F.Mesh.Scale = F.Mesh.Scale * 1.08
					elseif F:FindFirstChild("SpecialMesh") then
						F.SpecialMesh.TextureId = ""
						F.SpecialMesh.Scale = F.SpecialMesh.Scale * 1.08
					end
				end
				if F:FindFirstChildWhichIsA("Decal") then
					F:FindFirstChildWhichIsA("Decal"):Destroy()	
				end

				F.Name = "EffectPart"
				F.Size = v.Size * 1.08
				F.Material = Enum.Material.Neon
				F.CanCollide = false
				F.Massless = true
				F.Anchored = false
				F.CFrame = v.CFrame
				F.Color = Color
				F.Transparency = .15
				local WELD = Instance.new("Weld")
				WELD.Part0 = F
				WELD.Part1 = v
				WELD.Parent = F
				F.Parent = game.Workspace.Thrown
				game.Debris:AddItem(F,.25)
				ts:Create(F, TweenInfo.new(.25, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false), {Transparency = 1}):Play()
				if F:FindFirstChildWhichIsA("Decal") then
					F:FindFirstChildWhichIsA("Decal"):Destroy()	
				end
			end
		end
	end)
end







local function smashintoground(part,size)
	spawn(function()
		local Player = play

		while true do game:GetService("RunService").Heartbeat:wait() --wait()
			if Player.Character:FindFirstChild("Executeable") then break end
			if Player.Character:FindFirstChild("Carried") then break end
			if Player.Character.Humanoid:GetState() == Enum.HumanoidStateType.Ragdoll then break end
			local ignore = {Player.Character,workspace.CurrentCamera}

			local hit, pos, sf = ray(part.Position + Vector3.new(0,5,0), part.Position - Vector3.new(0,10,0), 12)
			if hit and hit.Parent ~= Player.Character and hit.Name == "Water"  and hit.Anchored then
				local Brick = Instance.new("Part", workspace)
				Brick.Size = Vector3.new(1,1,1)
				Brick.Anchored = true
				Brick.Transparency = 1
				Brick.CanCollide = false
				Brick.Position = pos
				local sound = script.Water:Clone()
				sound.Pitch = math.random(11,13)/10
				sound.Parent = Player.Character.HumanoidRootPart
				sound:Play()
				local Shockwave = script.Ring2:Clone()
				Shockwave.Parent = workspace
				Shockwave.Position = Brick.Position
				Shockwave.CFrame = Shockwave.CFrame * CFrame.Angles(math.pi/2,0,0)
				Shockwave.BrickColor = hit.BrickColor
				local shake = script.Shake:Clone()
				shake.Value =Brick.Position
				shake.Power.Value =70
				shake.Parent = game.Workspace.Thrown
				game.Debris:AddItem(shake,2)
				ts:Create(Shockwave.Mesh, TweenInfo.new(0.35, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
					Scale =Shockwave.Mesh.Scale + Vector3.new(Shockwave.Mesh.Scale.Y * size*1.5,Shockwave.Mesh.Scale.Y *size*1.5,Shockwave.Mesh.Scale.Y * size/5)
				}):Play()

				ts:Create(Shockwave, TweenInfo.new(0.35, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
					Transparency = 1
				}):Play()
				game.Debris:AddItem(sound, 6)
				local Parti = script.WaterParticle:Clone()
				Parti.Parent = Brick
				Parti:Emit(45)
				game.Debris:AddItem(Brick, 2)
				break end

			if hit and hit.Parent ~= Player.Character and hit.ClassName ~= "Tool" and hit.Anchored and hit.CanCollide and hit.Transparency ~=  1  then
				print(hit.Name)
				--[[local Brick = Instance.new("Part", workspace)
				Brick.Anchored = true
				Brick.CanCollide = false
				Brick.Position = pos]]


				local sound = script.Down2:Clone()
				sound.Pitch = math.random(11,13)/10
				sound.Parent = Player.Character.HumanoidRootPart
				sound:Play()
				game.Debris:AddItem(sound, 6)
				local CloudEffect = script.Cloud:Clone()
				CloudEffect.Parent = workspace
				CloudEffect.BrickColor = hit.BrickColor
				CloudEffect.Position = pos
				local shake = script.Shake:Clone()
				shake.Value =CloudEffect.Position
				shake.Power.Value = 70
				shake.Parent = game.Workspace.Thrown
				game.Debris:AddItem(shake,2)
				local Shockwave = script.Ring2:Clone()
				Shockwave.Parent = workspace
				Shockwave.Position = CloudEffect.Position
				Shockwave.CFrame = Shockwave.CFrame * CFrame.Angles(math.pi/2,0,0)
				Shockwave.BrickColor = hit.BrickColor
				ts:Create(Shockwave.Mesh, TweenInfo.new(0.35, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
					Scale =Shockwave.Mesh.Scale + Vector3.new(Shockwave.Mesh.Scale.Y * size*1.5,Shockwave.Mesh.Scale.Y *size*1.5,Shockwave.Mesh.Scale.Y * size/5)
				}):Play()

				ts:Create(Shockwave, TweenInfo.new(0.35, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
					Transparency = 1
				}):Play()
				ts:Create(CloudEffect.Mesh, TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
					Scale =CloudEffect.Mesh.Scale + Vector3.new(CloudEffect.Mesh.Scale.Y * size/1.75,CloudEffect.Mesh.Scale.Y *size,CloudEffect.Mesh.Scale.Y * size/1.25)
				}):Play()
				wait(.255)
				ts:Create(CloudEffect.Mesh, TweenInfo.new(2, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
					Scale = CloudEffect.Mesh.Scale + Vector3.new(CloudEffect.Mesh.Scale.Y * .25,CloudEffect.Mesh.Scale.Y * .25,CloudEffect.Mesh.Scale.Y * .25)
				}):Play()
				ts:Create(CloudEffect, TweenInfo.new(2, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
					Transparency = 1,
				}):Play()

				game.Debris:AddItem(CloudEffect,4)
				game.Debris:AddItem(Shockwave,2)
				break end
		end
	end)
end
local function CamShake(pos,power)
	local shake = script.Shake:Clone()
	shake.Value = pos
	shake.Power.Value = power
	shake.Parent = game.Workspace.Thrown
	game.Debris:AddItem(shake,2)
end

local function xplode(eroot, sf, pos)
	local tring = script.Explod:clone()
	tring.CFrame = CFrame.new(pos) * CFrame.Angles(math.rad(math.random(0, 360)), math.rad(math.random(0, 360)), math.rad(math.random(0, 360)))
	tring.Parent = game.Workspace.Thrown
	ts:Create(tring, TweenInfo.new(math.random(60, 75) / 100, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
		Size = tring.Size * 20,
		Transparency = 1,
		CFrame = tring.CFrame * CFrame.Angles(math.rad(180), 0, 0)
	}):Play()
	game.Debris:AddItem(tring, 0.75)
	local tring = script.ThinRing:clone()
	tring.CFrame = CFrame.new(eroot.Position, eroot.Position + sf)
	tring.Parent = game.Workspace.Thrown
	ts:Create(tring, TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
		Size = tring.Size * 40,
		Transparency = 1
	}):Play()
	game.Debris:AddItem(tring, 1)
end



function explosioon(cf,power)
	Spawn(function()
		local Part1 = Instance.new("Part", workspace)
		Part1.Size = Vector3.new(1,1,1)
		Part1.Material = Enum.Material.Neon
		Part1.Anchored = true
		Part1.CanCollide = false
		Part1.Transparency = 0
		Part1.BrickColor = BrickColor.new("Bright red")
		Part1.Position = cf
		Part1.Shape = "Ball"
		local Light = script.PointLight:Clone()
		Light.Range = power *1.1
		Light.Brightness = 0
		Light.Parent = Part1
		local explsound = script["Explosion"..math.random(1,2)]:Clone()
		explsound.Pitch = .85
		if power <= 15 then
			explsound.Pitch = math.random(150,160)/100
		elseif power >= 25 then
			explsound.Pitch = math.random(125,130)/100
		elseif power >= 50 then
			explsound.Pitch = math.random(85,100)/100
		elseif power >= 100 then
			explsound.Pitch = math.random(65,75)/100
		end
		explsound.Parent = Part1
		explsound:Play()
		game.Debris:AddItem(explsound,3)
		local Part2 = Part1:Clone()
		Part2.BrickColor = BrickColor.new("Gold")
		Part2.Parent = workspace
		Part2.Size = Part1.Size/1.5
		Part2.CFrame = Part1.CFrame
		local RandomSpeed = math.random(40,50)/100
		if power>= 50 then
			spawn(function()
				local RANDOMO = math.random(1,3)
				for i = 1,RANDOMO do wait(.01)
					local Part = script.Ring:Clone()
					Part.Transparency = 0
					Part.CFrame = Part1.CFrame * CFrame.Angles(0,0,0)
					Part.Parent = workspace

					ts:Create(Part, TweenInfo.new(RandomSpeed-.1, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
						Size = Vector3.new(power*1.65+RANDOMO/10,power*.2,power*1.65+RANDOMO/5),
						Transparency = 1
					}):Play()
					game.Debris:AddItem(Part,1.5)
				end
			end)
		end
		ts:Create(Part1, TweenInfo.new(RandomSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
			Size = Vector3.new(power*1.25,power*1.25,power*1.25),
			Transparency = 1
		}):Play()
		ts:Create(Light, TweenInfo.new(RandomSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
			Brightness = 1
		}):Play()
		ts:Create(Part2, TweenInfo.new(RandomSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
			Size = Vector3.new(power*1,power*1,power*1),
			Transparency = 1
		}):Play()
		wait(RandomSpeed)
		ts:Create(Light, TweenInfo.new(RandomSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
			Brightness = 0
		}):Play()
		game.Debris:AddItem(Part1,1.5)
		game.Debris:AddItem(Part2,1.5)
	end)
end






local function downer(root, eroot)
	local s = script.Down:Clone()
	s.Parent = eroot
	s:Play()
	game.Debris:AddItem(s, 2)
	local tring = script.Impact:clone()
	tring.CFrame = CFrame.new(root.Position, eroot.Position) * CFrame.Angles(math.rad(-45), 0, 0)
	tring.Parent = game.Workspace.Thrown
	ts:Create(tring, TweenInfo.new(0.6, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
		Size = tring.Size * 8,
		Transparency = 1
	}):Play()
	game.Debris:AddItem(tring, 1)
	for i = 1, 2 do
		local tring = script.ThinRing:clone()
		tring.CFrame = CFrame.new(root.Position, eroot.Position) * CFrame.Angles(math.rad(-45), 0, 0)
		tring.Parent = game.Workspace.Thrown
		ts:Create(tring, TweenInfo.new(0.1 * i, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
			Size = tring.Size * 25,
			Transparency = 1
		}):Play()
		game.Debris:AddItem(tring, 0.3)
	end
	local s = script.Away:Clone()
	s.Parent = eroot
	s:Play()
	game.Debris:AddItem(s, 3)
end
local function away(root, eroot)
	for i = 1, 5 do
		local tring = script.ThinRing:clone()
		tring.CFrame = CFrame.new(eroot.Position, eroot.Position - root.CFrame.lookVector) * CFrame.Angles(math.rad(math.random(0, 360)), math.rad(math.random(0, 360)), math.rad(math.random(0, 360)))
		tring.Parent = game.Workspace.Thrown
		ts:Create(tring, TweenInfo.new(math.random(20, 30) / 100, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
			Size = tring.Size * 30,
			Transparency = 1,
			CFrame = tring.CFrame * CFrame.Angles(math.rad(180), 0, 0)
		}):Play()
		game.Debris:AddItem(tring, 0.3)
	end
	local s = script.Away:Clone()
	s.Parent = eroot
	s:Play()
	game.Debris:AddItem(s, 3)
end
local function kbanim(root, eroot)
	local tring = script.ThinRing:clone()
	tring.CFrame = CFrame.new(eroot.Position, eroot.Position - root.CFrame.lookVector)
	tring.Parent = game.Workspace.Thrown
	ts:Create(tring, TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
		Size = tring.Size * 30,
		Transparency = 1
	}):Play()
	game.Debris:AddItem(tring, 0.5)
	local crown = script.Crown:Clone()
	crown.CFrame = CFrame.new(eroot.Position, eroot.Position - root.CFrame.lookVector) * CFrame.Angles(math.rad(-90), 0, 0)
	crown.Parent = game.Workspace.Thrown
	crown.Transparency = 0.5
	ts:Create(crown, TweenInfo.new(0.3, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
		Size = tring.Size * Vector3.new(20, 30, 20),
		Transparency = 1,
		CFrame = crown.CFrame * CFrame.Angles(0, math.rad(180), 0)
	}):Play()
	local s = script.Strong:Clone()
	s.Parent = eroot
	s:Play()
	game.Debris:AddItem(s, 2)
	game.Debris:AddItem(crown, 0.3)
	spawn(function()
		for i = 1, 22 do
			local part = script.Line:clone()
			part.CFrame = CFrame.new(eroot.Position, eroot.Position - root.CFrame.lookVector) * CFrame.new(math.random(-5, 5), math.random(-5, 5), math.random(-10, 10))
			part.Parent = game.Workspace.Thrown
			ts:Create(part, TweenInfo.new(math.random(10, 100) / 100, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
				CFrame = part.CFrame * CFrame.new(0, 0, math.random(30, 60)),
				Transparency = 1
			}):Play()
			game.Debris:AddItem(part, 1)
		end
	end)
end
function ray(startpos, endpos, dis, ign)
	local test = Ray.new(startpos, CFrame.new(startpos, endpos).lookVector * dis)
	local hit, pos, sf = game.Workspace:FindPartOnRayWithIgnoreList(test, {
		game.Workspace.LivingThings,
		game.Workspace.Thrown,
		ign
	})
	return hit, pos, sf
end
local function Impact(cf, size)
	local tring = script.Impact:clone()
	tring.CFrame = cf
	tring.Parent = game.Workspace.Thrown
	ts:Create(tring, TweenInfo.new(math.random(20, 30) / 100, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
		Size = tring.Size * size,
		Transparency = 1
	}):Play()
	game.Debris:AddItem(tring, 0.3)
end

local function grow(part, size, secs, distance, char)
	if part then
		local tweenInfo = TweenInfo.new(.8, Enum.EasingStyle.Linear)
		local TargetC = char.Head.CFrame *CFrame.new(0, 0, -distance)

		local rx = math.random(0, 360)
		local ry = math.random(0, 360)
		local rz = math.random(0, 360)

		TargetC = TargetC *CFrame.Angles(math.rad(rx), math.rad(ry), math.rad(rz))

		part.CFrame = part.CFrame *CFrame.Angles(-rx, -ry, -rz)

		local tween1 = TweenService:Create(part, tweenInfo, {Transparency = 1, CFrame = TargetC, Size = part.Size + Vector3.new(size,size,size)})tween1:Play()
	end
end

local function grow2(part, size, secs, distance, char)
	if part then
		local tweenInfo = TweenInfo.new(.4, Enum.EasingStyle.Linear)
		local TargetC = char.Head.CFrame *CFrame.new(0, 0, -distance)

		local rx = math.random(0, 360)
		local ry = math.random(0, 360)
		local rz = math.random(0, 360)

		TargetC = TargetC *CFrame.Angles(math.rad(rx), math.rad(ry), math.rad(rz))

		part.CFrame = part.CFrame *CFrame.Angles(-rx, -ry, -rz)

		local tween1 = TweenService:Create(part, tweenInfo, {Transparency = 1, CFrame = TargetC, Size = part.Size + Vector3.new(size,size,size)})tween1:Play()
	end
end

local function shatter(part)
	part.Transparency = 1
	if part then
		for i = 1,100 do
			local par = script.Shatter:Clone()
			par.CanCollide = false
			par.Anchored = false
			par.CFrame = part.CFrame *CFrame.new(math.random(-part.Size.X/2, part.Size.X/2), math.random(-part.Size.Y/2, part.Size.Y/2), math.random(-part.Size.Z/2, part.Size.Z/2))
			par.Parent = game.Workspace.Thrown
			par.Velocity = Vector3.new(math.random(-part.Size.X/2, part.Size.X/2), 0, math.random(-part.Size.X/2, part.Size.X/2))

		end
	end
end

local function Whirlwind(plr)
	local part = script.Whirlwind:Clone()
	if plr.Parent:FindFirstChild("UsingGates") then
		part.BrickColor = BrickColor.new("Really red")
	end
	part.Anchored = false
	local weld = Instance.new("Weld")
	weld.Parent = part
	weld.Part0 = part
	weld.Part1 = plr
	weld.C1 = weld.C1 *CFrame.new(0, -.5, 0)
	part.Parent = game.Workspace.Thrown
	game:GetService("Debris"):AddItem(part, 5)
	ts:Create(part, TweenInfo.new(0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false), {Transparency = .4}):Play()
	ts:Create(part.Mesh, TweenInfo.new(.8, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false), {Scale = Vector3.new(5, .8, 5)}):Play()
	ts:Create(weld, TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false), {C1 = weld.C1 *CFrame.new(0, 1, 0)}):Play()
	spawn(function()
		for i = 1,6 do
			ts:Create(weld, TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false), {C0 = weld.C0 *CFrame.Angles(0, math.rad(140), 0)}):Play()
			wait(.2)
		end
	end)
	wait(.105)
	local x = game.ReplicatedStorage.FallPart2:Clone()
	x.Parent = game.Workspace.Thrown
	game:GetService("Debris"):AddItem(x, 5)

	x.Anchored = true
	x.Position = plr.Position -Vector3.new(0, plr.Size.Y/1.8, 0)

	ts:Create(part, TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false), {Transparency = 1}):Play()
	spawn(function()
		for i = 1,10 do
			x.Position = plr.Position -Vector3.new(0, plr.Size.Y/1.8, 0)
			x.Smoke:Emit(2)
			wait()
		end
	end)
end

local function Slice(cf, size, col)
	local tring = script.Cut:clone()
	tring.CFrame = cf
	tring.Color = col
	tring.Size = tring.Size * size / 2
	tring.Transparency = .25
	tring.Parent = game.Workspace.Thrown
	local Newsize = tring.Size * 1.25
	spawn(function()
		ts:Create(tring, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut, 0, false), {Transparency = 1,Size = Newsize}):Play()
	end)
	ts:Create(tring, TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
		CFrame = cf * CFrame.Angles(0, math.rad(160), 0)
	}):Play()
	game.Debris:AddItem(tring, 1)
end
local function SliceNoSpin(cf, size, col)
	local tring = script.Cut:clone()
	tring.CFrame = cf
	tring.Color = col
	tring.Size = tring.Size * size / 2
	tring.Transparency = .25
	tring.Parent = game.Workspace.Thrown
	local Newsize = tring.Size * 1.25
	spawn(function()
		ts:Create(tring, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut, 0, false), {Transparency = 1,Size = Newsize}):Play()
	end)

	game.Debris:AddItem(tring, 1)
end

local function SmokeEffect(CF,Size,Color,Amount)
	spawn(function()
		for i = 1,Amount do
			local Smoke = script.Cloud:Clone()
			Smoke.Parent = workspace
			Smoke.CFrame = CF
			Smoke.Transparency = .3
			if Amount > 1 then
				Smoke.CFrame = Smoke.CFrame * CFrame.new(math.random(-6,6),0,math.random(-6,6)) * CFrame.Angles(0,math.random(-math.pi,math.pi),0)
			end
			Smoke.Color = Color
			ts:Create(Smoke.Mesh, TweenInfo.new(0.3, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
				Scale =Smoke.Mesh.Scale + Vector3.new(Smoke.Mesh.Scale.Y * Size/1.75,Smoke.Mesh.Scale.Y *Size,Smoke.Mesh.Scale.Y * Size/1.25)
			}):Play()


			ts:Create(Smoke, TweenInfo.new(2, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut, 0, false), {Transparency =1}):Play()

			game.Debris:AddItem(Smoke,2.1)
		end
	end)
end

local function RisingSlice(cf, size, col)
	local tring = script.Cut:clone()
	tring.CFrame = cf
	tring.Color = col
	tring.Size = tring.Size * size / 2
	tring.Transparency = .55
	tring.Parent = game.Workspace.Thrown
	local Newsize = tring.Size * 1.25
	spawn(function()
		ts:Create(tring, TweenInfo.new(0.35, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut, 0, false), {Transparency = 1,Size = Newsize}):Play()
	end)
	ts:Create(tring, TweenInfo.new(0.35, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
		CFrame = cf * CFrame.Angles(0, math.rad(160), 0) * CFrame.new(0,math.random(15,20),0)
	}):Play()
	game.Debris:AddItem(tring, 1)
end

local function FastRing(cf, size)
	local tring = script.Ring:clone()
	tring.CFrame = cf * CFrame.Angles(0, math.rad(90), 0)
	tring.Parent = game.Workspace.Thrown
	ts:Create(tring, TweenInfo.new(0.3, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
		Size = tring.Size * size,
		Transparency = 1
	}):Play()
	game.Debris:AddItem(tring, 0.3)
end
local function LightFastRing(cf, size,col)
	local tring = script.Ring:clone()
	tring.CFrame = cf * CFrame.Angles(0, math.rad(90), 0)
	tring.Parent = game.Workspace.Thrown
	tring.Color = col
	tring.Transparency = 0
	ts:Create(tring, TweenInfo.new(0.15, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
		Size = tring.Size * size,
		Transparency = 1
	}):Play()
	game.Debris:AddItem(tring, 0.15)
end
local function Lines(cf, size,cf2,distance,speed,color,amount)
	spawn(function()
		--print("HM")
		if amount == nil then amount = 1 end
		for i = 1,amount do
			local part = script.Line:clone()
			local cf = CFrame.new(cf.p, cf2.p)
			local Dis = (cf.p - cf2.p).magnitude
			cf = cf *CFrame.new(0, 0, (-Dis))
			if color == nil then color = Color3.new(255,255,255) print("NO COLOR FOUND") end
			part.Color = color
			part.CFrame = cf * CFrame.new(math.random(-5, 5), math.random(-5, 5), math.random(-10, 10))
			part.Parent = game.Workspace.Thrown
			local timee = math.random(speed*10, speed*100) / 100
			ts:Create(part, TweenInfo.new(timee, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
				CFrame = part.CFrame * CFrame.new(0, 0, -math.random(distance, distance*2)),
				Transparency = 1
			}):Play()
			game.Debris:AddItem(part, timee)
		end
	end)
end
local function LightFastImpact(cf, size)
	local tring = script.Impact:clone()
	tring.CFrame = cf
	tring.Transparency = 0.7
	tring.Parent = game.Workspace.Thrown
	ts:Create(tring, TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
		Size = tring.Size * size,
		Transparency = 1
	}):Play()
	game.Debris:AddItem(tring, 0.2)
end
local function FastImpact(cf, size,col)
	local tring = script.Impact:clone()
	tring.CFrame = cf
	tring.Color = col
	tring.Parent = game.Workspace.Thrown
	ts:Create(tring, TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
		Size = tring.Size * size,
		Transparency = 1
	}):Play()
	game.Debris:AddItem(tring, 0.2)
end
local function Ball2(pos, lokat)
	local part = script.Ball2:clone()
	part.Mesh.Scale = Vector3.new(1, 1, 0)
	part.CFrame = CFrame.new(pos, lokat)
	local ti = TweenInfo.new(0.15, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true)
	local tween1 = ts:Create(part.Mesh, ti, {
		Scale = Vector3.new(0.9, 0.9, 10),
		Offset = Vector3.new(0, 0, 9)
	})
	tween1:Play()
	local ti = TweenInfo.new(0.15, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true)
	local tween1 = ts:Create(part, ti, {
		CFrame = part.CFrame * CFrame.new(0, 0, -16)
	})
	tween1:Play()
	local ti2 = TweenInfo.new(0.35, Enum.EasingStyle.Quint, Enum.EasingDirection.In, 0)
	local tween2 = ts:Create(part, ti2, {Transparency = 1})
	tween2:Play()
	part.Sound:Play()
	part.Parent = game.Workspace
	game.Debris:AddItem(part, 0.35)
end
local function Ball3(pos, lokat)
	local part = script.Ball3:clone()
	part.CFrame = CFrame.new(pos, lokat)
	local ti = TweenInfo.new(0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true)
	local tween1 = ts:Create(part.Mesh, ti, {
		Scale = Vector3.new(1, 1, 10),
		Offset = Vector3.new(0, 0, 9)
	})
	tween1:Play()
	local ti = TweenInfo.new(0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true)
	local tween1 = ts:Create(part, ti, {
		CFrame = part.CFrame * CFrame.new(0, 0, -25)
	})
	tween1:Play()
	local ti2 = TweenInfo.new(0.1, Enum.EasingStyle.Quint, Enum.EasingDirection.In, 0)
	local tween2 = ts:Create(part, ti2, {Transparency = 1})
	tween2:Play()
	part.Sound:Play()
	part.Parent = game.Workspace
	game.Debris:AddItem(part, 0.1)
end


local function SandPath(val)
	local PART = script.SandPath:Clone()
	PART.CFrame = val.HumanoidRootPart.CFrame * CFrame.new(0,-3,-1.5)
	PART.Parent = workspace.Thrown
	--PART.Spawn:Play()
	game.Debris:AddItem(PART,1.5)
end

local function IceSlide(val)
	local PART = script.IceSlide:Clone()
	PART.CFrame = val.HumanoidRootPart.CFrame * CFrame.new(0,-3,-1.5)
	PART.Parent = workspace.Thrown
	--PART.Spawn:Play()
	game.Debris:AddItem(PART,1.5)
end

local function WaterSlide(val)
	local PART = script.WaterSlide:Clone()
	PART.CFrame = val.HumanoidRootPart.CFrame * CFrame.new(0,-3,-1.5)
	PART.Parent = workspace.Thrown
	--PART.Spawn:Play()
	game.Debris:AddItem(PART,1.5)
end

local function GoldPath(val)
	local PART = script.GoldPath:Clone()
	PART.CFrame = val.HumanoidRootPart.CFrame * CFrame.new(0,-3,-1.5)
	PART.Parent = workspace.Thrown
	--PART.Spawn:Play()
	game.Debris:AddItem(PART,1.5)
end

local function Surfboard(val)
	local PART = script.Surfboard:Clone()
	PART.CFrame = val.HumanoidRootPart.CFrame * CFrame.new(0,-3,-1.5)
	PART.Parent = workspace.Thrown
	--PART.Spawn:Play()
	game.Debris:AddItem(PART,0.05)
end

local function Firesurf(val)
	local PART = script.Firesurf:Clone()
	PART.CFrame = val.HumanoidRootPart.CFrame * CFrame.new(0,-3,-1.5)
	PART.Parent = workspace.Thrown
	--PART.Spawn:Play()
	game.Debris:AddItem(PART,0.2)
end

local function Ball4(pos, lokat, t)
	local part = script.Ball4:clone()
	if t == true and math.random(1, 2) == 2 then
		part.BrickColor = BrickColor.new("Neon orange")
	end
	part.CFrame = CFrame.new(pos, lokat)
	local ti = TweenInfo.new(0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true)
	local tween1 = ts:Create(part.Mesh, ti, {
		Scale = Vector3.new(1, 1, 10),
		Offset = Vector3.new(0, 0, 9)
	})
	tween1:Play()
	local ti = TweenInfo.new(0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true)
	local tween1 = ts:Create(part, ti, {
		CFrame = part.CFrame * CFrame.new(0, 0, -25)
	})
	tween1:Play()
	local ti2 = TweenInfo.new(0.1, Enum.EasingStyle.Quint, Enum.EasingDirection.In, 0)
	local tween2 = ts:Create(part, ti2, {Transparency = 1})
	tween2:Play()
	part.Sound:Play()
	part.Parent = game.Workspace
	game.Debris:AddItem(part, 0.1)
end
local function Ball1(pos, lokat)
	local part = script.Ball:clone()
	part.CFrame = CFrame.new(pos, lokat)
	local ti = TweenInfo.new(0.15, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true)
	local tween1 = ts:Create(part.Mesh, ti, {
		Scale = Vector3.new(0.9, 0.9, 10),
		Offset = Vector3.new(0, 0, 9)
	})
	tween1:Play()
	local ti = TweenInfo.new(0.15, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true)
	local tween1 = ts:Create(part, ti, {
		CFrame = part.CFrame * CFrame.new(0, 0, -18)
	})
	tween1:Play()
	local ti2 = TweenInfo.new(0.3, Enum.EasingStyle.Quint, Enum.EasingDirection.In, 0)
	local tween2 = ts:Create(part, ti2, {Transparency = 1})
	tween2:Play()
	local ti2 = TweenInfo.new(0.35, Enum.EasingStyle.Quint, Enum.EasingDirection.In, 0)
	local tween2 = ts:Create(part.Union, ti2, {Transparency = 1})
	tween2:Play()
	part.Sound:Play()
	part.Parent = game.Workspace
	game.Debris:AddItem(part, 0.35)
end

local function splash(cf,Power,color)
	spawn(function()
		if Power == nil then Power = 1 end
		if color == nil then color = Color3.fromRGB(255, 255, 255) end
		local explo = script.Splash:clone()
		local CFramee = CFrame.new(cf.X,-1,cf.Z)
		explo:SetPrimaryPartCFrame(CFramee)
		local model = explo
		explo.Parent = workspace
		for _,v in pairs(model:GetChildren()) do
			if v.ClassName =="Part" or v.ClassName =="MeshPart" then
				if v.Color == Color3.fromRGB(255, 255, 0) or v.Color == Color3.fromRGB(245, 205, 48) then
					v.Color = color
				end
				local OrginalSize = v.Size
				v.Size = Vector3.new(0,0,0)
				if v:FindFirstChild("PointLight") then
					local oldlightsize = v.PointLight.Range 
					v.PointLight.Range = 0
					if color then
						v.PointLight.Color = color
					end
					ts:Create(v.PointLight, TweenInfo.new(0.35, Enum.EasingStyle.Linear, Enum.EasingDirection.In),
						{Range = oldlightsize*Power}):Play()
				end
				if v:FindFirstChild("Mesh") then
					local mesh = v:FindFirstChild("Mesh")
					local Oldscale = mesh.Scale 
					mesh.Scale = Vector3.new(0,0,0)
					ts:Create(mesh, TweenInfo.new(0.35, Enum.EasingStyle.Linear, Enum.EasingDirection.In),
						{Scale = Oldscale*Power}):Play()
					if v.Name == "Cloud" or  v.Name == "Explosion" then
						spawn(function()
							wait(.4)
							ts:Create(mesh, TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.In),
								{Scale = Vector3.new(mesh.Scale.X/2,0,mesh.Scale.Z/2)}):Play()
							ts:Create(mesh.Parent, TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.In),
								{Transparency = 1}):Play()
						end)
					end
					if v.Name == "Shockwave" then
						ts:Create(mesh.Parent, TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.In),
							{Transparency = 1}):Play()
					end
				end
				ts:Create(v, TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.In),
					{Size = OrginalSize*Power}):Play()
			end
		end
		wait(.1)
		game.Debris:AddItem(explo,3)
	end)
end

local function Fastsplash(cf,Power,color)
	spawn(function()
		if Power == nil then Power = 1 end
		if color == nil then color = Color3.fromRGB(255, 255, 255) end
		local explo = script.Splash:clone()
		local CFramee = CFrame.new(cf.X,-1,cf.Z)
		explo:SetPrimaryPartCFrame(CFramee)
		local model = explo
		explo.Parent = workspace
		for _,v in pairs(model:GetChildren()) do
			if v.ClassName =="Part" or v.ClassName =="MeshPart" then
				if v.Color == Color3.fromRGB(255, 255, 0) or v.Color == Color3.fromRGB(245, 205, 48) then
					v.Color = color
				end
				local OrginalSize = v.Size
				v.Size = Vector3.new(0,0,0)
				if v:FindFirstChild("PointLight") then
					local oldlightsize = v.PointLight.Range 
					v.PointLight.Range = 0
					if color then
						v.PointLight.Color = color
					end
					ts:Create(v.PointLight, TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.In),
						{Range = oldlightsize*Power}):Play()
				end
				if v:FindFirstChild("Mesh") then
					local mesh = v:FindFirstChild("Mesh")
					local Oldscale = mesh.Scale 
					mesh.Scale = Vector3.new(0,0,0)
					ts:Create(mesh, TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.In),
						{Scale = Oldscale*Power}):Play()
					if v.Name == "Cloud" or  v.Name == "Explosion" then
						spawn(function()
							wait(.25)
							ts:Create(mesh, TweenInfo.new(.65, Enum.EasingStyle.Linear, Enum.EasingDirection.In),
								{Scale = Vector3.new(mesh.Scale.X/2,0,mesh.Scale.Z/2)}):Play()
							ts:Create(mesh.Parent, TweenInfo.new(.65, Enum.EasingStyle.Linear, Enum.EasingDirection.In),
								{Transparency = 1}):Play()
						end)
					end
					if v.Name == "Shockwave" then
						ts:Create(mesh.Parent, TweenInfo.new(0.65, Enum.EasingStyle.Linear, Enum.EasingDirection.In),
							{Transparency = 1}):Play()
					end
				end
				ts:Create(v, TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.In),
					{Size = OrginalSize*Power}):Play()
			end
		end
		wait(.1)
		game.Debris:AddItem(explo,3)
	end)
end

local function Explosion(cf,Power,color)
	spawn(function()
		if Power == nil then Power = 1 end
		if color == nil then color = Color3.fromRGB(255, 255, 0) end
		local explo = script.Explosion:Clone()
		explo:SetPrimaryPartCFrame(cf)
		local model = explo
		local ExplosionSound = script.Explosion1:Clone()
		ExplosionSound.Parent= explo.PrimaryPart
		ExplosionSound:Play()
		explo.Parent = workspace
		explo.Script.Disabled = false
		for _,v in pairs(model:GetChildren()) do
			if v.ClassName =="Part" or v.ClassName =="MeshPart" then
				if v.Color == Color3.fromRGB(255, 255, 0) or v.Color == Color3.fromRGB(245, 205, 48) then
					v.Color = color
				end
				local OrginalSize = v.Size
				v.Size = Vector3.new(0,0,0)
				if v:FindFirstChild("PointLight") then
					local oldlightsize = v.PointLight.Range 
					v.PointLight.Range = 0
					if color then
						v.PointLight.Color = color
					end
					ts:Create(v.PointLight, TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.In),
						{Range = oldlightsize*Power}):Play()
				end
				if v:FindFirstChild("Mesh") then
					local mesh = v:FindFirstChild("Mesh")
					local Oldscale = mesh.Scale 
					mesh.Scale = Vector3.new(0,0,0)
					ts:Create(mesh, TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.In),
						{Scale = Oldscale*Power}):Play()
				end
				ts:Create(v, TweenInfo.new(0.25, Enum.EasingStyle.Linear, Enum.EasingDirection.In),
					{Size = OrginalSize*Power}):Play()
			end
		end
		wait(.15)
		spawn(function()
			for _,v in pairs(model:GetChildren()) do
				if v.Name == "Smoke" then
					spawn(function()
						for i = 1, 100 do
							if v.Mesh:FindFirstChild("asd") then
								v.Mesh.Scale = v.Mesh.Scale + Vector3.new(0.05, -0.05, 0.05)
							else
								v.Mesh.Scale = v.Mesh.Scale + Vector3.new(0.05, 0.05, 0.05)
							end
							v.Transparency = v.Transparency + 0.01
							game:GetService("RunService").Heartbeat:wait()
						end
					end)
				end
			end

		end)

		for _,v in pairs(model:GetChildren()) do
			if v.Name == "Explosive" then
				spawn(function()
					for i = 1, 60 do
						v.Transparency = v.Transparency + 0.02
						game:GetService("RunService").Heartbeat:wait()
					end
					v:Destroy()
				end)
			end
		end

		for _,v in pairs(model:GetChildren()) do
			if v.Name == "CloudExplo" then
				spawn(function()
					for i = 1, 70 do
						if v:FindFirstChild("PointLight") then
							v.PointLight.Range = v.PointLight.Range - 0.15
						end
						if v:FindFirstChild("Mesh") then
							v.Mesh.Scale = v.Mesh.Scale + Vector3.new(0.1, 0.1, 0.1)
						else
							local savedcf = v.CFrame
							v.Size = v.Size + Vector3.new(0.1, 0.1, 0.1)
							v.CFrame = savedcf
						end
						v.Transparency = v.Transparency + 0.02
						game:GetService("RunService").Heartbeat:wait()
					end
					v:Destroy()
				end)
			end
		end
		game.Debris:AddItem(model,4)
	end)
end

local function soru(root)
	local Soru = script.Soru:Clone()
	Soru.CFrame = root.CFrame
	Soru.Parent = workspace
	Soru.SoruP:Emit(5)
	Soru.Soru:Play()
	game.Debris:AddItem(Soru,1.5)
end

local function Debris(pos, copypart, size)
	spawn(function()


		local part2 = script.Debris2:Clone()
		part2.CFrame = CFrame.new(pos)
		part2.Parent = workspace.Thrown
		local PartColor = copypart.Color
		local Red = PartColor.r * 255
		local Green = PartColor.g * 255
		local Blue = PartColor.b * 255
		--print("COLOR IS "..colorconvert)
		part2.Parti.Color = ColorSequence.new(Color3.fromRGB(Red,Green,Blue))
		local emitthing = math.random(10,15)+size/2
		part2.Parti:Emit(emitthing)
		game.Debris:AddItem(part2,10)

		for i = 1,math.random(7,15) do


			local part = script.Debris:clone()
			part.Parent = game.Workspace.Thrown
			part.Size = part.Size * math.random(.5,1)
			part.CFrame = CFrame.new(pos) * CFrame.new(math.random(-5,5),0,math.random(-5,5))
			part.Velocity = Vector3.new(math.random(-75,75),math.random(45,75),math.random(-75,75))
			part.BrickColor = copypart.BrickColor
			part.Material = copypart.Material
			spawn(function()
				wait(.75)
				local ti = TweenInfo.new(3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, true)
				local tween1 = ts:Create(part, ti, {
					Transparency = 1
				})
				tween1:Play()
				game.Debris:AddItem(part, 3)
			end)
		end
	end)
end		

local en = true
game.ReplicatedStorage:WaitForChild("Effect").OnClientEvent:connect(function(typ, root, eroot, sf, pos,extra,extra2,extra3)
	if not en then
		return
	end
	en = false
	spawn(function()
		sf = sf or nil
		pos = pos or nil
		root = root or nil
		eroot = eroot or nil
		typ = typ or nil
		if typ then--SmokeFade(CF2,FadeTime,Size)
			if typ == "Impact" then
				Impact(root, eroot)
			elseif typ == "FastImpact" then
				FastImpact(root, eroot)
			elseif typ == "Whirlwind" then
				Whirlwind(root)
			elseif typ == "grow" then
				grow(root, eroot, sf, pos, extra)
			elseif typ == "shatter" then
				shatter(root)
			elseif typ == "grow2" then
				grow2(root, eroot, sf, pos, extra)
			elseif typ == "dragontail" then
				waterdragontail(root,eroot)
			elseif typ == "windtail" then
				waterdragontail(root,eroot)
			elseif typ == "GroundImpact" then
				smashintoground(root, eroot)
			elseif typ == "LookVectorKnockBack" or  typ == "LookVectorVelocity"  then
				LookVectorKnockBack(root, eroot,sf,pos)--Parent,Velocity Power,Time Untill its destroyed
			elseif typ == "DirectionalKnockBack" then
				DirectionalKnockBack(root, eroot,sf,pos,extra,extra2)--Part1, Part2, Velocity Power, Time Untill Destroyed
			elseif typ == "RemoveVelocity" then
				RemoveVelocity(root)--Character Value of who to destroy velocites in
			elseif typ == "Explosion" then
				Explosion(root, eroot, sf)
			elseif typ == "FastRing" then
				FastRing(root, eroot)
			elseif typ == "SmokeFade" then
				SmokeFade(root,eroot,sf,pos,extra)
			elseif typ == "LightFastRing" then
				LightFastRing(root, eroot)
			elseif typ == "LightFastImpact" then
				LightFastImpact(root, eroot)
			elseif typ == "kbanim" then
				kbanim(root, eroot)
			elseif typ == "Ball2" then
				Ball2(root, eroot)
			elseif typ == "Smoke" then
				SmokeEffect(root,eroot,sf,pos)  --SmokeEffect(CF,Size,Color,Amount)
			elseif typ == "Ball1" then
				Ball1(root, eroot)
			elseif typ == "Shake" or typ == "CamShake" then
				CamShake(root, eroot)
			elseif typ == "Lines" then
				Lines(root, eroot,sf,pos,extra,extra2,extra3)
			elseif typ == "Ball3" then
				Ball3(root, eroot)
			elseif typ == "Ball4" then
				Ball4(root, eroot, sf)
			elseif typ == "away" then
				away(root, eroot)
			elseif typ == "slice" then
				Slice(root, eroot, sf)
			elseif typ == "slicenospin" then
				SliceNoSpin(root, eroot, sf)
			elseif typ == "slicerise" then
				RisingSlice(root, eroot, sf)
				--	elseif typ == "Explosion" then
				--	Explosion(root,eroot,sf)
			elseif typ == "Splash" then
				splash(root,eroot,sf)
			elseif typ == "FastSplash" then
				Fastsplash(root,eroot,sf)
			elseif typ == "downer" then
				downer(root, eroot)
			elseif typ == "Soru" then
				soru(root)
			elseif typ == "Debris" then
				Debris(root, eroot, sf)
			elseif typ == "bodyflicker" then
				bodyflicker(root, eroot, sf)
			elseif typ == "xplode" then
				xplode(eroot, sf, pos)
			elseif typ == "SandPath" then
				SandPath(root)
			elseif typ == "IceSlide" then
				IceSlide(root)
			elseif typ == "WaterSlide" then
				WaterSlide(root)
			elseif typ == "GoldPath" then
				GoldPath(root)
			elseif typ == "Surfboard" then
				Surfboard(root)
			elseif typ == "Firesurf" then
				Firesurf(root)
			elseif typ == "look" or typ == "LookAt" then
				LookAt(root,eroot)
			elseif typ == "Bleed" then
				bleed(root,eroot,sf)
			elseif typ == "Clone" then
				Clone(root,eroot,sf,pos,extra)
			elseif typ == "Debris" then
				Debris(root, eroot, sf)
			elseif typ == "PresetEffect" then
				PresetEffect(root,eroot,sf,pos,extra)
			elseif typ == "upanim" then
				upanim(eroot)
			elseif typ == "CombatVelocity" then
				combatknockback(root,eroot,sf,pos,extra)
			elseif typ == "Lightning" then
				GenerateLightning(root,eroot,sf,pos,extra, extra2, extra3)
			elseif typ == "Gust" then--sphereshockwave
				gust(root)
			elseif typ == "Hoppa" then--sphereshockwave
				hoppa(root)
			elseif typ == "SphereShockwave" then--sphereshockwave
				sphereshockwave(root,eroot,sf,pos)
			elseif typ == "SphereShockwave2" then--sphereshockwave
				sphereshockwave2(root,eroot,sf,pos)
			elseif typ == "FloatingRocks" then
				FloatingRocks(root)
			elseif typ == "thinring" then
				thinring(eroot, sf, pos)
			end
		end
	end)
	en = true
end)
for a, b in pairs(game.Workspace.Thrown:GetChildren()) do
	if b.Name == "Generator" then
		b:Destroy()
	end
end
local ones = {}
local twos = {}
local en = true
